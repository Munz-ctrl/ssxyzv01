<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

let renderer, scene, camera, controls, group, ground, key, amb;
let frontMesh = null, backMesh = null;

const stage = document.getElementById("stage");
const speedEl = document.getElementById("speed");
const shadowEl = document.getElementById("shadow");
const lightEl = document.getElementById("light");
const autoEl = document.getElementById("auto");
const speedVal = document.getElementById("speedVal");
const shadowVal = document.getElementById("shadowVal");
const lightVal = document.getElementById("lightVal");
const resetBtn = document.getElementById("reset");
const frontFile = document.getElementById("frontFile");
const backFile = document.getElementById("backFile");
const usePlaceholdersBtn = document.getElementById("usePlaceholders");

init();
animate();

function init() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias:true });
  document.body.appendChild(renderer.domElement);
  resizeRenderer();

  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;

  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  // Camera
  const aspect = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(30, aspect, 0.1, 100);
  camera.position.set(0, 1.2, 3.2);

  // Controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 0.9, 0);

  // Lights
  amb = new THREE.AmbientLight(0xffffff, 0.72);
  scene.add(amb);
  key = new THREE.DirectionalLight(0xffffff, 0.9);
  key.castShadow = true;
  key.shadow.mapSize.set(1024,1024);
  key.shadow.radius = 4;
  scene.add(key);
  setKeyAngle(parseFloat(lightEl.value));

  // Ground
  const smat = new THREE.ShadowMaterial({ opacity: parseFloat(shadowEl.value) });
  ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), smat);
  ground.receiveShadow = true;
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  group = new THREE.Group();
  scene.add(group);

  window.addEventListener("resize", resizeRenderer);
  speedEl.addEventListener("input", () => speedVal.textContent = (+speedEl.value).toFixed(2));
  shadowEl.addEventListener("input", () => { ground.material.opacity = +shadowEl.value; shadowVal.textContent = shadowEl.value; });
  lightEl.addEventListener("input", () => { setKeyAngle(+lightEl.value); lightVal.textContent = lightEl.value + "Â°"; });
  resetBtn.addEventListener("click", () => { camera.position.set(0, 1.2, 3.2); controls.target.set(0, 0.9, 0); controls.update(); });
  frontFile.addEventListener("change", handleFrontUpload);
  backFile.addEventListener("change", handleBackUpload);
  usePlaceholdersBtn.addEventListener("click", loadPlaceholders);

  loadPlaceholders();
}

function resizeRenderer() {
  const w = window.innerWidth * 0.7;  // ~70% width for stage
  const h = window.innerHeight;
  renderer.setSize(w, h, false);
  if (camera) {
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  if (stage && renderer.domElement.parentNode !== stage) {
    stage.innerHTML = "";
    stage.appendChild(renderer.domElement);
  }
}

function setKeyAngle(deg) {
  const rad = THREE.MathUtils.degToRad(deg);
  const r = 2.2;
  key.position.set(Math.cos(rad)*r, 2.1, Math.sin(rad)*r);
}

function animate() {
  requestAnimationFrame(animate);
  if (autoEl.checked && group) {
    const spd = parseFloat(speedEl.value);
    group.rotation.y += 0.005 * spd;
  }
  controls.update();
  renderer.render(scene, camera);
}

async function handleFrontUpload(e) {
  if (!e.target.files?.length) return;
  const url = URL.createObjectURL(e.target.files[0]);
  const tex = await loadTexture(url);
  applyFront(tex);
}

async function handleBackUpload(e) {
  if (!e.target.files?.length) return;
  const url = URL.createObjectURL(e.target.files[0]);
  const tex = await loadTexture(url);
  applyBack(tex);
}

function applyFront(tex) {
  if (frontMesh) cleanupMesh(frontMesh);
  frontMesh = makePlaneFromTexture(tex);
  frontMesh.rotation.y = Math.PI/4;
  group.add(frontMesh);
}
function applyBack(tex) {
  if (backMesh) cleanupMesh(backMesh);
  backMesh = makePlaneFromTexture(tex);
  backMesh.rotation.y = -Math.PI/4;
  group.add(backMesh);
}

function makePlaneFromTexture(tex) {
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 8;
  const H = 1.7;
  const aspect = tex.image.width / tex.image.height;
  const W = H * aspect;
  const geo = new THREE.PlaneGeometry(W, H);
  const mat = new THREE.MeshPhongMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
  const m = new THREE.Mesh(geo, mat);
  m.castShadow = true;
  m.position.y = H * 0.52;
  return m;
}

function cleanupMesh(m) {
  group.remove(m);
  m.material.map?.dispose();
  m.material.dispose();
  m.geometry.dispose();
}

function loadTexture(url) {
  return new Promise((res, rej) => {
    new THREE.TextureLoader().load(url, tex => res(tex), undefined, err => rej(err));
  });
}

// Placeholder images
function loadPlaceholders() {
  Promise.all([ makePlaceholderTexture("FRONT"), makePlaceholderTexture("BACK") ])
    .then(([f,b]) => { applyFront(f); applyBack(b); });
}

function makePlaceholderTexture(label="FRONT") {
  const w = 1024, h = 1536;
  const c = document.createElement("canvas"); c.width=w; c.height=h;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#e9eef5"; ctx.fillRect(w*0.18,h*0.12,w*0.64,h*0.76);
  ctx.fillStyle="#2b2b2b";
  ctx.font="bold 80px system-ui"; ctx.textAlign="center";
  ctx.fillText(label,w/2,h*0.55);
  const tex = new THREE.CanvasTexture(c);
  return Promise.resolve(tex);
}
</script>
