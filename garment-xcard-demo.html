<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>X-Card Garment Turntable – Demo</title>
<style>
  :root { --bg:#111; --panel:#1b1b1b; --text:#e8e8e8; --muted:#8d8d8d; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  .wrap { display:grid; grid-template-columns: 1fr 320px; gap:14px; height:100%; }
  #stage { position:relative; background:#fff; }
  #hud { background:var(--panel); padding:14px; border-left:1px solid #262626; display:flex; flex-direction:column; gap:12px; }
  .row { display:flex; align-items:center; gap:10px; }
  .row label { width:110px; color:var(--muted); }
  input[type="range"] { width:100%; }
  input[type="file"] { width:100%; }
  .btn { background:#2a2a2a; color:#fff; border:1px solid #333; padding:8px 10px; border-radius:8px; cursor:pointer; }
  .hint { color:var(--muted); font-size:12px; }
  .title { font-weight:700; font-size:16px; margin-bottom:2px; }
</style>
</head>
<body>
<div class="wrap">
  <div id="stage"></div>

  <aside id="hud">
    <div class="title">X-Card Turntable</div>
    <div class="hint">Upload any front/back photo (PNG/JPG). Transparent PNGs look best.</div>

    <div class="row"><label>Front image</label><input id="frontFile" type="file" accept="image/*"></div>
    <div class="row"><label>Back image</label><input id="backFile" type="file" accept="image/*"></div>
    <div class="row"><button id="usePlaceholders" class="btn">Use placeholders</button></div>

    <hr style="border:0;border-top:1px solid #2a2a2a">

    <div class="row"><label>Spin speed</label><input id="speed" type="range" min="0" max="2" step="0.01" value="0.5"><span id="speedVal">0.50</span></div>
    <div class="row"><label>Shadow</label><input id="shadow" type="range" min="0" max="0.5" step="0.01" value="0.18"><span id="shadowVal">0.18</span></div>
    <div class="row"><label>Light angle</label><input id="light" type="range" min="-90" max="90" step="1" value="35"><span id="lightVal">35°</span></div>
    <div class="row"><label>Auto-orbit</label><input id="auto" type="checkbox" checked></div>
    <div class="row"><button id="reset" class="btn">Reset view</button></div>

    <div class="hint">Tip: try rotating with your mouse (OrbitControls). The two planes cross at 90° to form the “X”.</div>
  </aside>
</div>

<!-- Three.js r160 + OrbitControls -->
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

let renderer, scene, camera, controls, group, ground, key, amb;
let frontMesh = null, backMesh = null;

const stage = document.getElementById("stage");
const speedEl = document.getElementById("speed");
const shadowEl = document.getElementById("shadow");
const lightEl = document.getElementById("light");
const autoEl = document.getElementById("auto");
const speedVal = document.getElementById("speedVal");
const shadowVal = document.getElementById("shadowVal");
const lightVal = document.getElementById("lightVal");
const resetBtn = document.getElementById("reset");
const frontFile = document.getElementById("frontFile");
const backFile = document.getElementById("backFile");
const usePlaceholdersBtn = document.getElementById("usePlaceholders");

init();
animate();

function init() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias:true });
  resizeRenderer();
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  stage.appendChild(renderer.domElement);

  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  // Camera
  const aspect = stage.clientWidth / stage.clientHeight;
  camera = new THREE.PerspectiveCamera(30, aspect, 0.1, 100);
  camera.position.set(0, 1.2, 3.2);

  // Controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.target.set(0, 0.9, 0);

  // Lights
  amb = new THREE.AmbientLight(0xffffff, 0.72);
  scene.add(amb);

  key = new THREE.DirectionalLight(0xffffff, 0.9);
  key.castShadow = true;
  key.shadow.mapSize.set(2048, 2048);
  key.shadow.radius = 4;
  scene.add(key);
  setKeyAngle(parseFloat(lightEl.value));

  // Ground (soft shadow)
  const smat = new THREE.ShadowMaterial({ opacity: parseFloat(shadowEl.value) });
  ground = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), smat);
  ground.receiveShadow = true;
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Garment group
  group = new THREE.Group();
  scene.add(group);

  // UI events
  window.addEventListener("resize", resizeRenderer);
  speedEl.addEventListener("input", () => speedVal.textContent = (+speedEl.value).toFixed(2));
  shadowEl.addEventListener("input", () => { ground.material.opacity = +shadowEl.value; shadowVal.textContent = shadowEl.value; });
  lightEl.addEventListener("input", () => { setKeyAngle(+lightEl.value); lightVal.textContent = lightEl.value + "°"; });
  resetBtn.addEventListener("click", () => { camera.position.set(0, 1.2, 3.2); controls.target.set(0, 0.9, 0); controls.update(); });
  frontFile.addEventListener("change", handleFrontUpload);
  backFile.addEventListener("change", handleBackUpload);
  usePlaceholdersBtn.addEventListener("click", loadPlaceholders);

  // Start with placeholders so you can see something immediately
  loadPlaceholders();
}

function resizeRenderer() {
  const w = stage.clientWidth || window.innerWidth;
  const h = stage.clientHeight || window.innerHeight;
  if (renderer) renderer.setSize(w, h, false);
  if (camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); }
}

function setKeyAngle(deg) {
  const rad = THREE.MathUtils.degToRad(deg);
  const r = 2.2;
  key.position.set(Math.cos(rad) * r, 2.1, Math.sin(rad) * r);
}

function animate(t=0) {
  requestAnimationFrame(animate);
  const auto = autoEl.checked;
  if (auto && group) {
    const spd = parseFloat(speedEl.value);
    group.rotation.y += 0.005 * spd; // ~0.5x base
  }
  controls.update();
  renderer.render(scene, camera);
}

// ---------- X-Card building ----------

async function handleFrontUpload(e) {
  if (!e.target.files?.length) return;
  const url = URL.createObjectURL(e.target.files[0]);
  const tex = await loadTexture(url);
  applyFront(tex);
}

async function handleBackUpload(e) {
  if (!e.target.files?.length) return;
  const url = URL.createObjectURL(e.target.files[0]);
  const tex = await loadTexture(url);
  applyBack(tex);
}

function applyFront(tex) {
  if (frontMesh) { group.remove(frontMesh); frontMesh.material.map?.dispose(); frontMesh.material.dispose(); frontMesh.geometry.dispose(); }
  frontMesh = makePlaneFromTexture(tex);
  // Rotate to +45°
  frontMesh.rotation.y =  Math.PI/4;
  group.add(frontMesh);
}

function applyBack(tex) {
  if (backMesh) { group.remove(backMesh); backMesh.material.map?.dispose(); backMesh.material.dispose(); backMesh.geometry.dispose(); }
  backMesh = makePlaneFromTexture(tex);
  // Rotate to -45°
  backMesh.rotation.y = -Math.PI/4;
  group.add(backMesh);
}

// Create a plane that matches the image aspect, with reasonable world height.
function makePlaneFromTexture(tex) {
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 8;

  // Target world height (meters); adjust to taste.
  const H = 1.7;
  const aspect = tex.image.width / tex.image.height;
  const W = H * aspect;

  const geo = new THREE.PlaneGeometry(W, H, 1, 1);
  const mat = new THREE.MeshPhongMaterial({
    map: tex,
    transparent: true,
    side: THREE.DoubleSide
  });

  const m = new THREE.Mesh(geo, mat);
  m.castShadow = true;
  m.position.y = H * 0.52; // lift so it sits above ground visually
  return m;
}

function loadTexture(url) {
  return new Promise((resolve, reject) => {
    const loader = new THREE.TextureLoader();
    loader.load(url, tex => resolve(tex), undefined, err => reject(err));
  });
}

// ---------- Placeholders so the effect is visible without uploads ----------

function loadPlaceholders() {
  Promise.all([ makePlaceholderTexture("FRONT"), makePlaceholderTexture("BACK") ])
    .then(([front, back]) => { applyFront(front); applyBack(back); });
}

function makePlaceholderTexture(label="FRONT") {
  const w = 1024, h = 1536;
  const cnv = document.createElement("canvas"); cnv.width = w; cnv.height = h;
  const ctx = cnv.getContext("2d");

  // background transparent; draw a soft “garment” rounded rect
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#e9eef5";
  roundRect(ctx, w*0.18, h*0.12, w*0.64, h*0.76, 40);
  ctx.fill();

  // collar notch
  ctx.clearRect(w*0.43, h*0.12, w*0.14, h*0.05);

  // label
  ctx.fillStyle = "#2b2b2b";
  ctx.font = "bold 80px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.textAlign = "center";
  ctx.fillText(label, w/2, h*0.55);

  // subtle alpha outside
  // (nothing; transparency shows through)

  const tex = new THREE.CanvasTexture(cnv);
  return Promise.resolve(tex);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}

</script>
</body>
</html>
